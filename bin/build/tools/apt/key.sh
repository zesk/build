#!/usr/bin/env bash
#
# apt functions
#
# Copyright &copy; 2025 Market Acumen, Inc.

__aptKeyAdd() {
  local handler="$1" && shift

  local names=() title="" remoteUrls=() skipUpdate=false listName="" releaseName="" repoUrl=""
  local name url host index IFS file listTarget
  local start ring sourcesPath keyFile skipUpdate signFiles signFileText sourceType sourceTypes=(deb)
  local installFlag=false

  # _IDENTICAL_ argumentNonBlankLoopHandler 6
  local __saved=("$@") __count=$#
  while [ $# -gt 0 ]; do
    local argument="$1" __index=$((__count - $# + 1))
    # __IDENTICAL__ __checkBlankArgumentHandler 1
    [ -n "$argument" ] || __throwArgument "$handler" "blank #$__index/$__count ($(decorate each quote -- "${__saved[@]}"))" || return $?
    case "$argument" in
    # _IDENTICAL_ helpHandler 1
    --help) "$handler" 0 && return $? || return $? ;;
    --name)
      shift
      names+=("$(usageArgumentString "$handler" "$argument" "${1-}")") || return $?
      ;;
    --skip)
      skipUpdate=true
      ;;
    --title)
      shift
      title="$(usageArgumentString "$handler" "$argument" "${1-}")" || return $?
      ;;
    --source)
      shift
      sourceTypes+=("$(usageArgumentString "$handler" "$argument" "${1-}")") || return $?
      ;;
    --repository-url)
      shift
      repoUrl="$(usageArgumentURL "$handler" "$argument" "${1-}")" || return $?
      ;;
    --list)
      shift
      listName="$(usageArgumentString "$handler" "$argument" "${1-}")" || return $?
      ;;
    --release)
      shift
      releaseName="$(usageArgumentString "$handler" "$argument" "${1-}")" || return $?
      ;;
    --url)
      shift
      remoteUrls+=("$(usageArgumentURL "$handler" "$argument" "${1-}")") || return $?
      ;;
    --install) installFlag=true ;;
    *)
      # _IDENTICAL_ argumentUnknownHandler 1
      __throwArgument "$handler" "unknown #$__index/$__count \"$argument\" ($(decorate each code -- "${__saved[@]}"))" || return $?
      ;;
    esac
    shift
  done

  start=$(timingStart) || return $?
  sourcesPath="$(_usageAptSourcesPath "$handler")" || return $?
  ring=$(_usageAptKeyRings "$handler") || return $?

  local installs=()
  whichExists gpg || installs+=("gpg")
  whichExists --any curl wget || installs+=("curl")
  if [ ${#installs[@]} -gt 0 ]; then
    if $installFlag; then
      __catch "$handler" packageInstall "${installs[@]}" || return $?
    else
      __throwEnvironment "$handler" "Unable to install packages: $(decorate each "${installs[@]}")" || return $?
    fi
  fi
  # apt-key is deprecated for good reasons
  # https://stackoverflow.com/questions/68992799/warning-apt-key-is-deprecated-manage-keyring-files-in-trusted-gpg-d-instead

  [ "${#names[@]}" -gt 0 ] || __throwArgument "$handler" "Need at least one --name" || return $?
  [ "${#remoteUrls[@]}" -gt 0 ] || __throwArgument "$handler" "Need at least one --url" || return $?
  [ "${#names[@]}" -eq "${#remoteUrls[@]}" ] || __throwArgument "$handler" "Mismatched --name and --url pairs: ${#names[@]} != ${#remoteUrls[@]}" || return $?

  __catch "$handler" packageWhich lsb_release lsb-release || return $?

  [ -n "$releaseName" ] || releaseName="$(__catchEnvironment "$handler" lsb_release -cs)" || return $?

  _usageAptPermissions "$handler" "$sourcesPath" || return $?

  index=0
  for name in "${names[@]}"; do
    url="${remoteUrls[index]}"
    host=$(urlParseItem host "$url") || __throwArgument "$handler" "Unable to get host from $url" || return $?
    title="${title:-"$name"}"

    statusMessage decorate info "Fetching $title key ... "
    keyFile="$ring/$name.gpg"
    # curl used  -fsSL as options:
    __catchEnvironment "$handler" urlFetch "$url" | gpg --no-tty --batch --dearmor | tee "$keyFile" >/dev/null || return $?
    __catchEnvironment "$handler" chmod a+r "$keyFile" || return $?
    signFiles+=("$keyFile")
    index=$((index + 1))
  done

  [ -n "$repoUrl" ] || repoUrl="https://$host/"

  signFileText="$(listJoin "," "${signFiles[@]}")"
  statusMessage decorate info "Configuring repository ... "

  [ -n "$listName" ] || listName="${names[0]}"
  sourcesPath=$(_usageAptSourcesPath "$handler") || return $?
  listTarget="$sourcesPath/$listName.list"
  printf -- "%s\n" "# Generated by ${FUNCNAME[0]} on $(date "+%F %T")" >"$listTarget"
  for sourceType in "${sourceTypes[@]}"; do
    __catchEnvironment "$handler" printf -- "%s [signed-by=%s] %s %s %s\n" "$sourceType" "$signFileText" "$repoUrl" "$releaseName" "main" >>"$listTarget" || return $?
  done
  __catchEnvironment "$handler" chmod a+r "$listTarget" || return $?
  if ! $skipUpdate; then
    statusMessage --first decorate success "updating ... "
    __catch "$handler" packageUpdate --force || return $?
  else
    statusMessage --first decorate success "skipped ... "
  fi
  statusMessage --last timingReport "$start" "Added $title to sources in"
}
_aptKeyAdd() {
  # __IDENTICAL__ usageDocument 1
  usageDocument "${BASH_SOURCE[0]}" "${FUNCNAME[0]#_}" "$@"
}

__aptKeyRemove() {
  local handler="$1" && shift

  local names=() skipUpdate=false verboseFlag=false

  # _IDENTICAL_ argumentNonBlankLoopHandler 6
  local __saved=("$@") __count=$#
  while [ $# -gt 0 ]; do
    local argument="$1" __index=$((__count - $# + 1))
    # __IDENTICAL__ __checkBlankArgumentHandler 1
    [ -n "$argument" ] || __throwArgument "$handler" "blank #$__index/$__count ($(decorate each quote -- "${__saved[@]}"))" || return $?
    case "$argument" in
    # _IDENTICAL_ helpHandler 1
    --help) "$handler" 0 && return $? || return $? ;;
    --verbose) verboseFlag=true ;;
    --skip) skipUpdate=true ;;
    *) names+=("$argument") ;;
    esac
    shift
  done

  [ "${#names[@]}" -gt 0 ] || __throwArgument "$handler" "No keyNames supplied" || return $?

  local start ring sourcesPath

  start=$(timingStart) || return $?

  ring=$(_usageAptKeyRings "$handler") || return $?
  sourcesPath="$(_usageAptSourcesPath "$handler")" || return $?

  [ -d "$ring" ] || __throwEnvironment "$handler" "Unable to remove key as $ring is not a directory" || return $?

  _usageAptPermissions "$handler" "$sourcesPath" || return $?

  for name in "${names[@]}"; do
    for file in "$ring/$name.gpg" "$sourcesPath/$name.list"; do
      if [ -f "$file" ]; then
        ! $verboseFlag || statusMessage decorate warning "Removing $(decorate code "$file") ... "
        __catchEnvironment "$handler" rm -f "$file" || return $?
      else
        ! $verboseFlag || statusMessage decorate success "Already deleted $(decorate code "$file") ... "
      fi
    done
  done
  if ! $skipUpdate; then
    ! $verboseFlag || statusMessage decorate success "Updating apt sources ... "
    __catch "$handler" packageUpdate --force || return $?
  else
    ! $verboseFlag || statusMessage decorate success "Skipped update ... "
  fi
  ! $verboseFlag || statusMessage timingReport "$start" "Removed ${names[*]} from sources in "
}

# sources constant with checking
# Usage: {fn} usageFunction
_usageAptSourcesPath() {
  local handler="$1" sourcesPath
  sourcesPath=$(__catchEnvironment "$handler" aptSourcesDirectory) || return $?
  [ -d "$sourcesPath" ] || __throwEnvironment "$handler" "No $sourcesPath exists - not an apt system" || return $?
  printf "%s\n" "$sourcesPath"
}

# key rings directory constant with creation
_usageAptKeyRings() {
  local handler="$1" ring
  # In case this changes later and may fail
  ring=$(__catch "$handler" aptKeyRingDirectory) || return $?
  if ! [ -d "$ring" ]; then
    __catchEnvironment "$handler" mkdir -p "$ring" || return $?
    __catchEnvironment "$handler" chmod 0755 "$ring" || return $?
  fi
  printf "%s\n" "$ring"
}

# permissions check for sourcesPath modifications
_usageAptPermissions() {
  local handler="$1" sourcesPath="$2"
  touch "$sourcesPath/$$.test" 2>/dev/null || __throwEnvironment "$handler" "No permission to modify $sourcesPath, failing" || return $?
  rm -f "$sourcesPath/$$.test" 2>/dev/null || __throwEnvironment "$handler" "No permission to delete in $sourcesPath, failing" || return $?
}
